<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-10-06 Fri 10:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Eric Easley" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style>.meta { opacity: 0.75; margin-left: 1em; }</style>
<style>.accordion { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; padding: 0em 1em; margin-left: 1em; }</style>
<style>.accordion-head { cursor: pointer; }</style>
<style>.accordion-head > p:first-child { font-variant: small-caps; }</style>
<style>.accordion-body { max-height: 0em; transform: scaleY(0); transition: transform 0.3s; transform-origin: top; }</style>
<style>.accordion-body > p:first-child { margin-top: 0; padding-top: 0.5em; }</style>
<style>.accordion-head > p:last-child { margin-bottom: 0; padding-bottom: 0.5em; }</style>
<style>.accordion-body:hover { max-height: 10000em; transform: scaleY(1); }</style>
<style>.accordion-head:hover + .accordion-body { max-height: 10000em; transform: scaleY(1); }</style>
<style>.trigger { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; padding: 0.5em 1em; margin-left: 1em; }</style>
<style>.trigger:before { content: 'Trigger'; font-variant: small-caps; }</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc0dd6bf">1. Prior knowledge</a></li>
<li><a href="#orgd686809">2. Make illegal state unrepresentable</a></li>
<li><a href="#org664303c">3. Goals</a></li>
<li><a href="#orgdf30fbc">4. A rigorous interlude</a></li>
<li><a href="#orged4132e">5. How</a>
<ul>
<li><a href="#org938b8b7">5.1. Enums</a></li>
<li><a href="#orgee63b64">5.2. Disjoint unions</a></li>
<li><a href="#org667cf01">5.3. Refined types</a></li>
</ul>
</li>
<li><a href="#orgc002741">6. Why</a>
<ul>
<li><a href="#org3e6e993">6.1. Code quality</a></li>
<li><a href="#org45cc70d">6.2. Cognitive science</a></li>
</ul>
</li>
<li><a href="#orgaad6419">7. Summary</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc0dd6bf" class="outline-2">
<h2 id="orgc0dd6bf"><span class="section-number-2">1</span> Prior knowledge</h2>
<div class="outline-text-2" id="text-1">
<p>
You may have heard of "the billion dollar mistake". This is the name Tony Hoare gives to his introduction of the null reference in ALGOL. If you've ever experienced a <code>NullPointerException</code> or a <code>Cannot read property of null</code>, you're a victim of this mistake.
</p>

<p>
You may also have heard of admonitions against stringly typed programming. If you've ever written code like <code>$('#foo')</code> or <code>el.append('&lt;div&gt;Hello&lt;/div&gt;')</code>, you've been party to jQuery-induced stringly typed programming.
</p>

<p>
The problem common to both is that we're permitted to pass around nonsensical data that we have no hope of handling---<code>null</code>'s that we can't <code>render()</code> and <code>&lt;div &lt;table&gt;&gt;</code> that can't be given an interpretation in the DOM. That is, we've made it possible&#x2014;easy&#x2014;to represent illegal states.
</p>
</div>
</div>

<div id="outline-container-orgd686809" class="outline-2">
<h2 id="orgd686809"><span class="section-number-2">2</span> Make illegal state unrepresentable</h2>
<div class="outline-text-2" id="text-2">
<p>
Instead, we should seek to make illegal state unrepresentable. That is, for each type, our ideal is that it simply <i>can't</i> be used to describe things that are uninteresting or impossible by our business logic. Let's look at a few short examples to prime our intuition then try to make our slogan more precise.
</p>

<div class="org-src-container">
<pre><code class="src src-js">/* If we want to track course progress, we might be tempted to do something like: */
type CourseCompletionStateBad = string;

/* But this permits an infinite (up to hardware limits) number of course states. Perhaps all we really need is: */
type CourseCompletionStateGood = 'Unstarted' | 'Started' | 'Complete';

/* Imagine we want to talk about essay assignments: */
type AssignmentBad = {
  prompt: string,
  dueOn: string,
};
/* We'd do better with: */
type AssignmentGood = {
  prompt: string,
  dueOn: Date,
};
/* Now it's impossible to be `dueOn: 'yellow'`. */
</code></pre>
</div>

<p>
Don't worry too much about the details yet. As long the direction I'm gesturing in is now clear, we're ready to move on.
</p>

<div class="meta">
<p>
Any time you see a paragraph like this, it denotes meta content&#x2014;some description of the underlying thinking or why ideas are presented as they are. The hope is that they predict and alleviate frustrations. If they don't, feel free to skip them.
</p>

</div>

<div class="meta">
<p>
Now's as good a time as any to address what will be an ongoing tension in the series. Strong evidence suggests that cognitive load impairs learning and that "more realistic" scenarios impose more cognitive load. This suggests that we should present examples which are minimal and isolated, focusing solely on the core technique. However, this creates the danger of examples which seem pointless and rarefied. Research confirms that motivation is <i>also</i> import for learning outcomes. So the way I'll attempt to navigate this tension is by generally presenting simple unconvincing examples first before graduating to more difficult&#x2014;but more realistic and motivating&#x2014;examples.
</p>

</div>
</div>
</div>

<div id="outline-container-org664303c" class="outline-2">
<h2 id="org664303c"><span class="section-number-2">3</span> Goals</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>Learn what the slogan "make illegal state unrepresentable" means
<ul class="org-ul">
<li>You'll know you're on your way when you feel comfortable recalling the meaning of the slogan and can bring examples to mind</li>
<li>Check this goal off when you can generate and apply novel ways of making illegal state unrepresentable</li>
</ul></li>
<li>Learn some techniques for making illegal state unrepresentable
<ul class="org-ul">
<li>You'll know you're on our way when you can complete the accompanying exercises</li>
<li>Check this goal off when you're regularly applying these techniques in your day-to-day code</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgdf30fbc" class="outline-2">
<h2 id="orgdf30fbc"><span class="section-number-2">4</span> A rigorous interlude</h2>
<div class="outline-text-2" id="text-4">
<p>
(Feel free to skip this section if it doesn't excite you. It's mathy but may assure some that this slogan isn't all hand-waving.)
</p>

<p>
Our next step is to try to make the notion of a type's size more precise. Each type delimits a number of valid inhabitants. <code>boolean</code> has the two inhabitants <code>true</code> and <code>false</code>. <code>Natural</code> has the inhabitants <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, and so on.
</p>

<div class="meta">
<p>
Certain blocks will be highlighted and annotated like this so that they're easier to scan for.
</p>

<p>
Hover over a practice block to see the answer.
</p>

</div>

<div class="accordion">
<div class="accordion-head">
<p>
Practice
</p>

<p>
How many inhabitants are in <code>?boolean</code>?
</p>

</div>
<div class="accordion-body">
<p>
4 (<code>?</code> allows <code>null</code> <i>and</i> <code>undefined</code>.)
</p>

</div>

</div>

<p>
The cardinality of primitive types like this is usually pretty intuitive, but how do we build to more complex types? There are two basic building blocks from which we'll build more complex types out of primitive types.
</p>

<p>
The first is the union operation for types---<code>|</code> in <code>flow</code>. When we encounter this (as long as the types on either side are disjoint: <a href="https://flow.org/en/docs/types/unions/#toc-disjoint-unions">https://flow.org/en/docs/types/unions/#toc-disjoint-unions</a>), the total number of inhabitants is the sum of the number of inhabitants of the left hand type and the number of inhabitants of the right hand type. This is why union types are also sometimes called sum types. In symbols rather than words, where <code>τ</code> and <code>φ</code> are types and <code>σ(τ)</code> represents the cardinality of type <code>τ</code>:
</p>

<pre class="example">
σ(τ | φ) = σ(τ) + σ(φ)

We can start to convince ourselves it's true with examples like:

type boolean = true | false
σ(true) = 1 \text{(This is why types like these are called singleton types.)}
σ(false) = 1
σ(boolean) = σ(true | false) = σ(true) + σ(false) = 1 + 1

type ?boolean = boolean | null | void
σ(null) = 1
σ(void) = 1
σ(?boolean) = σ(boolean | null | void) = σ(boolean) + σ(null) + σ(void) = 2 + 1 + 1
</pre>

<div class="accordion">
<div class="accordion-head">
<p>
Practice
</p>

<p>
List out all the inhabitants of <code>?boolean</code>. Does it agree with our answer?
</p>

<p>
Derive the cardinality for <code>type CourseCompletionStateGood = 'Unstarted' | 'Started' | 'Complete'</code>.
</p>

</div>
<div class="accordion-body">
<div class="org-src-container">
<pre><code class="src src-js">type ?boolean = true | false | null | undefined;
σ(CourseCompletionStateGood) = σ('Unstarted') | σ('Started') | σ('Completed') = 1 + 1 + 1
</code></pre>
</div>

</div>

</div>

<p>
The other major building block for complex types is what we use when we build records and tuples (A tuple of <code>number</code> and <code>boolean</code> looks like <code>[number, boolean]</code> in <code>flow</code>.). In a tuple, the total number of inhabitants of the tuple is the product of the number of inhabitants of each side (hence, these are sometimes called product types). In symbols:
</p>

<pre class="example">
σ([τ, φ]) = σ(τ) · σ(φ)

We can start to convince ourselves it's true with examples like:

σ([Void, ?boolean])
  = σ(Void) · σ(?boolean)
  = 1 · 4
σ({ loggedIn: boolean, firstLogin: ?boolean })
  = σ({ loggedIn: boolean }) · σ({ firstLogin: ?boolean })
  = σ(boolean) · σ(?boolean)
  = 2 · 4
</pre>

<div class="accordion">
<div class="accordion-head">
<p>
Practice
</p>

<p>
List out all the inhabitants of <code>{ loggedIn: boolean, firstLogin: ?boolean }</code>. Does it agree with our answer?
</p>

</div>
<div class="accordion-body">
<div class="org-src-container">
<pre><code class="src src-js">type { loggedIn: boolean, firstLogin: ?boolean } =
  { loggedIn: true, firstLogin: true } |
  { loggedIn: true, firstLogin: false } |
  { loggedIn: true, firstLogin: null } |
  { loggedIn: true, firstLogin: undefined } |
  { loggedIn: false, firstLogin: true } |
  { loggedIn: false, firstLogin: false } |
  { loggedIn: false, firstLogin: null } |
  { loggedIn: false, firstLogin: undefined };
The 8 we see here agrees with our calculated answer.
</code></pre>
</div>

</div>

</div>

<p>
These two building blocks are enough to build enormously complex types&#x2014;lists, maps, enums, etc.
</p>

<p>
Our next step is to make the concept of illegal state a bit more precise. We can take either an operational or semantic perspective. The operational perspective says that an illegal state is one which is never occupied during any execution trace of the properly-functioning software. (This is less question-begging than it sounds because we define proper functioning of the software in terms of inputs and outputs while states can be purely internal.) The semantic perspective says that an illegal state is one which cannot be given a coherent meaning in the underlying domain that our software represents. In either case, we'll represent these valid states of <code>τ</code> as <code>{τ | β(τ)}</code> where <code>β</code> defines validity according to our business logic. (There's a notational collision here: <code>|</code> for union in <code>flow</code> and <code>|</code> for "such that" in set-builder notation. We can disambiguate by noting that set builder <code>|</code> is always and only enclosed by <code>{}</code> rather than <code>()</code>.)
</p>

<p>
With this machinery, we can rephrase. Instead of "make illegal state unrepresentable", we can say "use the business-logic-compatible type with minimum cardinality". Or equivalently for a fixed business logic, maximize <code>σ({τ | β(τ)}) / σ(τ)</code>. A value of <code>1</code> represents perfection with no illegal states remaining in the type.
</p>
</div>
</div>

<div id="outline-container-orged4132e" class="outline-2">
<h2 id="orged4132e"><span class="section-number-2">5</span> How</h2>
<div class="outline-text-2" id="text-5">
<p>
There are a variety of standard tricks for making illegal state unrepresentable that it will be useful to have in our bag.
</p>
</div>

<div id="outline-container-org938b8b7" class="outline-3">
<h3 id="org938b8b7"><span class="section-number-3">5.1</span> Enums</h3>
<div class="outline-text-3" id="text-5-1">
<p>
We already saw one example of this with <code>CourseCompletionState</code>. Here are others:
</p>

<div class="org-src-container">
<pre><code class="src src-js">type CourseTrackBad = string;
const courseTrackBad: CourseTrackBad = 'Nonsense';
/* Instead: */
type CourseTrackGood = 'Honors' | 'Standard' | 'Audit';
// This won't typecheck:
// const courseTrackGood: CourseTrackGood = 'Nonsense';

type StarRatingBad = number;
const starRatingBad: StarRatingBad = -1.2;
/* Instead: */
type StarRatingGood = 1 | 2 | 3 | 4 | 5;
// This won't typecheck:
// const starRatingGood: StarRatingGood = -1.2;
</code></pre>
</div>

<p>
The move here is to switch from a type like a string to a finite subset of that type which captures all the states we care about. This makes our intention clearer to the type checker and to readers.
</p>

<div class="meta">
<p>
Suppose we're convinced this technique is useful. It may still be difficult to put into practice because it's unfamiliar and we haven't yet built intuitions for when to use it. As a stepping stone on the way toward automaticity, this series will try to offer "action triggers" that prompt use of a technique. Through these we hope to transform the very hard (for the new initiate) task of "exercise your analytical abilities and judgment to find opportunities to apply any of a suite of techniques appropriately" to the simpler "remember these triggers and the corresponding technique for improvement". In the long term, this should build our capacity and familiarity and we'll eventually internalize these triggers and generate our own novel triggers and responses.
</p>

</div>

<div class="meta">
<p>
Relatedly, I'll suggest using these techniques more often than is comfortable when first starting out. In fact, by following this guidance I hope that you <i>will</i> use these techniques too often. Ultimately, for all these techniques, you'll want to settle on usage habits that make intelligent trade offs. But that judgement will be unrefined in the beginning and the only way to be gain confidence you've found the proper line is to cross it repeatedly./
</p>

</div>

<div class="trigger">
<p>
Any time you <code>switch</code> or use nested <code>if...else</code> on a value whose type has infinitely many values (e.g. <code>string</code>), there's a good chance you can make this change.
</p>

</div>
</div>
</div>

<div id="outline-container-orgee63b64" class="outline-3">
<h3 id="orgee63b64"><span class="section-number-3">5.2</span> Disjoint unions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
I'll rely on <a href="https://flow.org/en/docs/types/unions/#toc-disjoint-unions"><code>flow</code>'s explanation</a> for the basic technique here and leap right into some useful possibilities this technique offers.
</p>

<div class="org-src-container">
<pre><code class="src src-js">/* If a user can login via one of several methods, we might try: */
type LoginIdBad = {
  emailAddress?: string,
  openIdSub?: string,
  openIdAud?: string,
};

/* But this permits invalid values like: */
const loginId1: LoginIdBad = {
  emailAddress: 'hal@enfield.edu',
  openIdSub: 'Hal',
};
const loginId2: LoginIdBad = {
};

/* We'd be better off with: */
type LoginIdGood
  = { tag: 'EmailAddress', value: string }
  | { tag: 'OpenId', sub: string, aud: string };

const loginId3: LoginIdGood = { tag: 'EmailAddress', value: 'hal@enfield.edu' };
/* Will produce a type error if we uncomment: */
// const loginId4: LoginIdGood = { tag: 'OpenId', value: 'hal@enfield.edu', openIdSub: 'Hal' };
</code></pre>
</div>

<p>
The idea here is to make implicit cross-field correspondences explicit. In the original version, there was a hidden invariant that either <code>emailAddress</code> was absent and the other two fields were present or that <code>emailAddress</code> was present and the other two fields were absent. We can almost directly read off the previous sentence to explicitly encode these rules as a disjoint union.
</p>

<p>
Another short example:
</p>

<div class="org-src-container">
<pre><code class="src src-js">/* Suppose one must qualify for a course by either testing into it or taking a prerequisite course: */
type CourseQualificationBad = {
  prereqGrade?: number,
  testGrade?: number,
};
/* But this permits invalid values like: */
const courseQualificationsBad = {
  prereqGrade: 1,
  testGrade: 1,
};
/* Instead: */
type Either&lt;A, B&gt; = { tag: 'Left', value: A } | { tag: 'Right', value: B };
type CourseQualificationGood = Either&lt;{ prereqGrade: number }, { testGrade: number }&gt;;
const courseQualificationsGood: CourseQualificationGood = { tag: 'Left', value: 1 };
</code></pre>
</div>

<p>
This example has the same underlying logic as the previous example, but we declare a generic type <code>Either</code> that we can reuse over and over again in situations like this.
</p>

<div class="trigger">
<p>
Any time you see multiple nullable fields in a record, you should ask yourself, "Is it really true that every combination of null and non-null across these fields is valid?".
</p>

</div>
</div>
</div>

<div id="outline-container-org667cf01" class="outline-3">
<h3 id="org667cf01"><span class="section-number-3">5.3</span> Refined types</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre><code class="src src-js">/* We might start with something like this: */
type PersonBad = {
  name: string,
  age: number,
};
/* But this permits invalid values like: */
const personBad: PersonBad = {
  name: 'Hal Incandenza',
  age: -1,
};
/* Instead: */
class PositiveNumber {
  raw: number;
  constructor(num: number): PositiveNumber {
    if (num &gt;= 0) {
      this.raw = num;
      return this;
    } else {
      throw new TypeError('Number not positive');
    }
  }
  static make(num: number): ?PositiveNumber {
    try {
      return new PositiveNumber(num);
    } catch (e) {
      if (e instanceof TypeError) {
        return null;
      } else {
        throw e;
      }
    }
  }
}
type PersonGood = {
  name: string,
  age: PositiveNumber,
};
const personGood: PersonGood = {
  name: 'Hal Incandenza',
  age: new PositiveNumber(17),
};
</code></pre>
</div>

<p>
Here, we'd like to restrict a type to some subset of its inhabitants. But the subset in infinite so we can't just use the enum technique outlined earlier. Instead, we create a class whose only constructor performs the check for us at runtime. Now, our class acts as a witness for the property we care about. The only way to get <code>PositiveNumber</code> is by passing the <code>num &gt;= 0</code> check in the constructor so we can be confident that every <code>PositiveNumber</code> is greater than or equal to zero.
</p>

<div class="accordion">
<div class="accordion-head">
<p>
Practice
</p>

<p>
To convince yourself this technique works, try to construct a <code>PositiveNumber</code> that's less than 0. Absent dirty tricks, you should fail.
</p>

</div>

</div>

<p>
Another example:
</p>

<div class="org-src-container">
<pre><code class="src src-js">/* Suppose we want to track the history of IP addresses we've seen for a user: */
type ScaryTrackingDataBad = {
  knownIpAddresses: Array&lt;string&gt;,
};
/* But if we note the user's IP address on first page load, `knownIpAddresses` should never be empty. So instead: */
class NonEmptyArray&lt;A&gt; {
  raw: Array&lt;A&gt;;
  constructor(array: Array&lt;A&gt;): NonEmptyArray&lt;A&gt; {
    if (array.length !== 0) {
      this.raw = array;
      return this;
    } else {
      throw new TypeError('Array is empty');
    }
  }
  static make(array: Array&lt;A&gt;): ?NonEmptyArray&lt;A&gt; {
    try {
      return new NonEmptyArray(array);
    } catch (e) {
      if (e instanceof TypeError) {
        return null;
      } else {
        throw e;
      }
    }
  }
}
type ScaryTrackingDataBad = {
  knownIpAddresses: NonEmptyArray&lt;string&gt;,
};
</code></pre>
</div>

<p>
This non-empty array type turns out to be quite broadly useful because many array operations assume there's at least one element---<code>pop()</code>, <code>reduce()</code> without an initial value, etc. Over time, we'll build up a utility library of useful types like this that we can reuse again and again.
</p>

<div class="trigger">
<p>
It's hard to create an action trigger here because this technique will almost always be available and it'll be a matter of discretion when and to what extent you use it. Perhaps the best we can do to make this mechanical is commit a library of standard refined types to memory and be on the lookout for opportunities to use them.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-orgc002741" class="outline-2">
<h2 id="orgc002741"><span class="section-number-2">6</span> Why</h2>
<div class="outline-text-2" id="text-6">
<p>
We'll argue in a couple modes: intuitive appeals about code quality and attempts to ground ourselves in cognitive science.
</p>
</div>

<div id="outline-container-org3e6e993" class="outline-3">
<h3 id="org3e6e993"><span class="section-number-3">6.1</span> Code quality</h3>
<div class="outline-text-3" id="text-6-1">
<p>
I'll claim three benefits:
</p>

<ol class="org-ol">
<li>It should be uncontroversial that this approach necessarily rules out at least some defects&#x2014;those arising from illegal states that we've made unrepresentable.</li>
<li>This approach tends to improve the readability of our code. By encoding more invariants in the type system, we move knowledge from the private world of the implementer's mental model into a shared, manifest form&#x2014;code. We no longer have to trust that our inheritors&#x2014;or even ourselves at some later date!&#x2014;will notice that a learner <i>must</i> qualify for a course via a test or prerequisite course.</li>
<li>If we follow this policy comprehensively, it tends to push validations to the "outer shell" of the program. Because invalid inhabitants aren't even possible, we can't defer validations. Validating on our first receipt of data has the useful effect of clarifying all the central business logic since it has to deal with fewer invalidities and edge cases.</li>
</ol>
</div>
</div>

<div id="outline-container-org45cc70d" class="outline-3">
<h3 id="org45cc70d"><span class="section-number-3">6.2</span> Cognitive science</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Humans are bad at understanding sets and their inhabitants. The availability heuristic suggests that we let our thoughts be dominated by immediate and prominent inhabitants of a category. Said another way, our default mode is to forget edge cases. An unstructured attempt to manage this deficiency relies upon prospective memory (When we tell ourselves to purchase an item the next time we go to the grocery store, we are attempting to leverage prospective memory.). That is, when we leave invalid states representable, we are implicitly asking our future selves to remember to appropriately handle these states at every use site. Research demonstrates that our prospective memory is notably imperfect with a failure rate in the tens of percents. Furthermore, research shows that the demands we place on prospective memory aren't free. They diminish our available supply of cognitive resources by affecting things like working memory.
</p>

<p>
The type system approach to making illegal state unrepresentable I outlined here doesn't directly compensate for the availability heuristic (However, the action triggers and habits we talked about may help us get better at noticing these sorts of problems.). But it does ensure that any invalid states we discover need only be discovered once. Thereafter, these discoveries can be encoded in the type system, checked without fail, and forgotten, thereby freeing our cognitive resources for other tasks.
</p>
</div>
</div>
</div>

<div id="outline-container-orgaad6419" class="outline-2">
<h2 id="orgaad6419"><span class="section-number-2">7</span> Summary</h2>
<div class="outline-text-2" id="text-7">
<p>
I advocated for the slogan "make illegal state unrepresentable". This is about choosing types that, ideally, allow us to express only our business logic and nothing else. Pervasive use of enums, disjoint unions and refined types moves us toward this ideal. In addition to reducing defects, this can make our code more readable.
</p>
</div>
</div>
</div>
</body>
</html>
